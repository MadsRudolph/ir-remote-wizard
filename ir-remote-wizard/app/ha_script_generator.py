"""Generate Home Assistant script YAML from confirmed IR buttons.

Instead of baking button: entries into ESPHome firmware (requiring recompile +
OTA flash), this generates HA scripts that call the ESP32's existing generic
API services at runtime.  Users just do "Reload Scripts" in HA â€” instant.
"""

from __future__ import annotations

import logging
import os
import re

from .discovery import WizardSession
from .protocol_map import BUTTON_CATEGORIES, convert_code

logger = logging.getLogger(__name__)

# Map button categories to mdi icons
_CATEGORY_ICONS: dict[str, str] = {
    "Power": "mdi:power",
    "Volume": "mdi:volume-high",
    "Channel": "mdi:television",
    "Navigation": "mdi:gamepad",
    "Input": "mdi:video-input-hdmi",
    "Playback": "mdi:play-pause",
}

# Override specific button names for better icons
_BUTTON_ICONS: dict[str, str] = {
    "Power": "mdi:power",
    "Power_on": "mdi:power-on",
    "Power_off": "mdi:power-off",
    "Vol_up": "mdi:volume-plus",
    "Vol_down": "mdi:volume-minus",
    "Mute": "mdi:volume-mute",
    "Ch_up": "mdi:chevron-up",
    "Ch_down": "mdi:chevron-down",
    "Up": "mdi:arrow-up",
    "Down": "mdi:arrow-down",
    "Left": "mdi:arrow-left",
    "Right": "mdi:arrow-right",
    "Ok": "mdi:check-circle",
    "Back": "mdi:arrow-left-circle",
    "Menu": "mdi:menu",
    "Home": "mdi:home",
    "Guide": "mdi:book-open-variant",
    "Info": "mdi:information",
    "Source": "mdi:video-input-hdmi",
    "Input": "mdi:video-input-hdmi",
    "Play": "mdi:play",
    "Pause": "mdi:pause",
    "Stop": "mdi:stop",
    "Ff": "mdi:fast-forward",
    "Rw": "mdi:rewind",
    "Rec": "mdi:record",
    "Next": "mdi:skip-next",
    "Prev": "mdi:skip-previous",
}


def _sanitize_id(name: str) -> str:
    """Convert a name to a valid HA script entity ID segment."""
    return re.sub(r"[^a-z0-9_]", "_", name.lower()).strip("_")


def _icon_for_button(button_name: str) -> str:
    """Pick the best mdi icon for a button."""
    if button_name in _BUTTON_ICONS:
        return _BUTTON_ICONS[button_name]
    # Try matching by category
    for category, buttons in BUTTON_CATEGORIES.items():
        if button_name in buttons:
            return _CATEGORY_ICONS.get(category, "mdi:remote")
    return "mdi:remote"


def _format_data_value(value: int | str | list) -> str:
    """Format a service data value for YAML output."""
    if isinstance(value, int):
        return f"0x{value:X}" if value > 255 else str(value)
    if isinstance(value, list):
        return str(value)
    return f'"{value}"' if isinstance(value, str) else str(value)


def generate_ha_scripts(session: WizardSession) -> str:
    """Generate HA script YAML entries for all confirmed buttons.

    Returns a YAML string ready to append to HA's scripts.yaml.
    """
    if not session.confirmed_buttons:
        return "# No buttons were confirmed during discovery."

    brand = _sanitize_id(session.matched_brand or "custom")
    device_type = _sanitize_id(session.device_type or "device")
    device_name = _sanitize_id(session.device_name or "ir_blaster")

    # The HA service name prefix: esphome.<device_name>_<service>
    service_prefix = f"esphome.{device_name}"

    brand_label = session.matched_brand or "Custom"
    type_label = session.device_type or "Device"

    lines: list[str] = []
    lines.append(f"# {brand_label} {type_label} -- generated by IR Remote Wizard")
    lines.append("")

    for btn in session.confirmed_buttons:
        cmd = convert_code(btn.protocol, btn.address, btn.command, btn.raw_data)
        if not cmd:
            continue

        script_id = f"ir_{brand}_{device_type}_{_sanitize_id(btn.name)}"
        alias = f"{brand_label} {type_label} - {btn.name}"
        icon = _icon_for_button(btn.name)
        service_name = f"{service_prefix}_{cmd.service}"

        lines.append(f"{script_id}:")
        lines.append(f"  alias: \"{alias}\"")
        lines.append(f"  icon: {icon}")
        lines.append(f"  sequence:")
        lines.append(f"    - action: {service_name}")
        lines.append(f"      data:")

        for key, value in cmd.data.items():
            lines.append(f"        {key}: {_format_data_value(value)}")

        lines.append("")

    return "\n".join(lines)


def generate_ha_dashboard_card(session: WizardSession) -> str:
    """Generate a Lovelace button card snippet that calls the HA scripts."""
    if not session.confirmed_buttons:
        return ""

    brand = _sanitize_id(session.matched_brand or "custom")
    device_type = _sanitize_id(session.device_type or "device")

    lines: list[str] = []
    lines.append("type: grid")
    lines.append("cards:")

    for btn in session.confirmed_buttons:
        cmd = convert_code(btn.protocol, btn.address, btn.command, btn.raw_data)
        if not cmd:
            continue
        script_id = f"ir_{brand}_{device_type}_{_sanitize_id(btn.name)}"
        icon = _icon_for_button(btn.name)
        lines.append(f"  - type: button")
        lines.append(f"    name: \"{btn.name}\"")
        lines.append(f"    icon: {icon}")
        lines.append(f"    tap_action:")
        lines.append(f"      action: perform-action")
        lines.append(f"      perform_action: script.{script_id}")

    lines.append("columns: 3")
    return "\n".join(lines)


def save_ha_scripts(
    scripts_yaml: str,
    ha_config_dir: str,
) -> dict:
    """Append generated scripts to HA's scripts.yaml.

    Returns {"path": str, "merged": bool}.
    """
    scripts_path = os.path.join(ha_config_dir, "scripts.yaml")
    logger.info("save_ha_scripts: writing to %s", scripts_path)

    os.makedirs(os.path.dirname(scripts_path) or ".", exist_ok=True)

    if os.path.exists(scripts_path):
        with open(scripts_path, "r") as f:
            existing = f.read()

        # Check for duplicate script IDs already in the file
        new_ids = set(re.findall(r"^(ir_\w+):", scripts_yaml, re.MULTILINE))
        existing_ids = set(re.findall(r"^(ir_\w+):", existing, re.MULTILINE))
        dupes = new_ids & existing_ids

        if dupes:
            # Remove duplicate blocks from new content
            filtered_lines: list[str] = []
            skip = False
            for line in scripts_yaml.splitlines():
                id_match = re.match(r"^(ir_\w+):", line)
                if id_match:
                    skip = id_match.group(1) in dupes
                if not skip:
                    filtered_lines.append(line)
                elif line == "":
                    skip = False  # reset on blank line boundary
            scripts_yaml = "\n".join(filtered_lines)

        # Don't write if nothing left after dedup
        if not re.search(r"^ir_\w+:", scripts_yaml, re.MULTILINE):
            return {"path": scripts_path, "merged": True, "skipped_all": True}

        new_content = existing.rstrip() + "\n\n" + scripts_yaml.strip() + "\n"
        with open(scripts_path, "w") as f:
            f.write(new_content)
        return {"path": scripts_path, "merged": True}
    else:
        with open(scripts_path, "w") as f:
            f.write(scripts_yaml.strip() + "\n")
        return {"path": scripts_path, "merged": False}
