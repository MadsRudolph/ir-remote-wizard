"""Generate Home Assistant script YAML from confirmed IR buttons.

Instead of baking button: entries into ESPHome firmware (requiring recompile +
OTA flash), this generates HA scripts that call the ESP32's existing generic
API services at runtime.  Users just do "Reload Scripts" in HA â€” instant.
"""

from __future__ import annotations

import logging
import os
import re

from .discovery import WizardSession
from .protocol_map import BUTTON_CATEGORIES, convert_code

logger = logging.getLogger(__name__)

# Map button categories to mdi icons
_CATEGORY_ICONS: dict[str, str] = {
    "Power": "mdi:power",
    "Volume": "mdi:volume-high",
    "Channel": "mdi:television",
    "Navigation": "mdi:gamepad",
    "Input": "mdi:video-input-hdmi",
    "Playback": "mdi:play-pause",
}

# Override specific button names for better icons
_BUTTON_ICONS: dict[str, str] = {
    "Power": "mdi:power",
    "Power_on": "mdi:power-on",
    "Power_off": "mdi:power-off",
    "Vol_up": "mdi:volume-plus",
    "Vol_down": "mdi:volume-minus",
    "Mute": "mdi:volume-mute",
    "Ch_up": "mdi:chevron-up",
    "Ch_down": "mdi:chevron-down",
    "Up": "mdi:arrow-up",
    "Down": "mdi:arrow-down",
    "Left": "mdi:arrow-left",
    "Right": "mdi:arrow-right",
    "Ok": "mdi:check-circle",
    "Back": "mdi:arrow-left-circle",
    "Menu": "mdi:menu",
    "Home": "mdi:home",
    "Guide": "mdi:book-open-variant",
    "Info": "mdi:information",
    "Source": "mdi:video-input-hdmi",
    "Input": "mdi:video-input-hdmi",
    "Play": "mdi:play",
    "Pause": "mdi:pause",
    "Stop": "mdi:stop",
    "Ff": "mdi:fast-forward",
    "Rw": "mdi:rewind",
    "Rec": "mdi:record",
    "Next": "mdi:skip-next",
    "Prev": "mdi:skip-previous",
}


# Icon colors by category for mushroom cards
_CATEGORY_COLORS: dict[str, str] = {
    "Power": "red",
    "Volume": "teal",
    "Channel": "blue",
    "Navigation": "purple",
    "Input": "indigo",
    "Playback": "green",
}

_BUTTON_COLORS: dict[str, str] = {
    "Power": "red",
    "Power_on": "green",
    "Power_off": "red",
    "Mute": "red",
    "Vol_up": "teal",
    "Vol_down": "teal",
}


def _color_for_button(button_name: str) -> str:
    """Pick a mushroom icon_color for a button."""
    if button_name in _BUTTON_COLORS:
        return _BUTTON_COLORS[button_name]
    for category, buttons in BUTTON_CATEGORIES.items():
        if button_name in buttons:
            return _CATEGORY_COLORS.get(category, "blue")
    return "blue"


def _sanitize_id(name: str) -> str:
    """Convert a name to a valid HA script entity ID segment."""
    return re.sub(r"[^a-z0-9_]", "_", name.lower()).strip("_")


def _icon_for_button(button_name: str) -> str:
    """Pick the best mdi icon for a button."""
    if button_name in _BUTTON_ICONS:
        return _BUTTON_ICONS[button_name]
    # Try matching by category
    for category, buttons in BUTTON_CATEGORIES.items():
        if button_name in buttons:
            return _CATEGORY_ICONS.get(category, "mdi:remote")
    return "mdi:remote"


def _format_data_value(value: int | str | list) -> str:
    """Format a service data value for YAML output."""
    if isinstance(value, int):
        return f"0x{value:X}" if value > 255 else str(value)
    if isinstance(value, list):
        return str(value)
    return f'"{value}"' if isinstance(value, str) else str(value)


def generate_ha_scripts(session: WizardSession) -> str:
    """Generate HA script YAML entries for all confirmed buttons.

    Returns a YAML string ready to append to HA's scripts.yaml.
    """
    if not session.confirmed_buttons:
        return "# No buttons were confirmed during discovery."

    brand = _sanitize_id(session.matched_brand or "custom")
    device_type = _sanitize_id(session.device_type or "device")
    device_name = _sanitize_id(session.device_name or "ir_blaster")

    # The HA service name prefix: esphome.<device_name>_<service>
    service_prefix = f"esphome.{device_name}"

    brand_label = session.matched_brand or "Custom"
    type_label = session.device_type or "Device"

    lines: list[str] = []
    lines.append(f"# {brand_label} {type_label} -- generated by IR Remote Wizard")
    lines.append("")

    for btn in session.confirmed_buttons:
        cmd = convert_code(btn.protocol, btn.address, btn.command, btn.raw_data)
        if not cmd:
            continue

        script_id = f"ir_{brand}_{device_type}_{_sanitize_id(btn.name)}"
        alias = f"{brand_label} {type_label} - {btn.name}"
        icon = _icon_for_button(btn.name)
        service_name = f"{service_prefix}_{cmd.service}"

        lines.append(f"{script_id}:")
        lines.append(f"  alias: \"{alias}\"")
        lines.append(f"  icon: {icon}")
        lines.append(f"  sequence:")

        for i in range(cmd.repeat):
            lines.append(f"    - action: {service_name}")
            lines.append(f"      data:")
            for key, value in cmd.data.items():
                lines.append(f"        {key}: {_format_data_value(value)}")
            if cmd.repeat > 1 and i < cmd.repeat - 1:
                lines.append(f"    - delay:")
                lines.append(f"        milliseconds: 45")

        lines.append("")

    return "\n".join(lines)


def generate_ha_dashboard_card(session: WizardSession) -> str:
    """Generate Mushroom template cards in horizontal-stack pairs.

    Produces a stack-in-card with mushroom-template-card buttons grouped
    in rows of two, matching the existing IR Remote dashboard style.
    """
    if not session.confirmed_buttons:
        return ""

    brand = _sanitize_id(session.matched_brand or "custom")
    device_type = _sanitize_id(session.device_type or "device")

    # Build card list
    cards: list[dict] = []
    for btn in session.confirmed_buttons:
        cmd = convert_code(btn.protocol, btn.address, btn.command, btn.raw_data)
        if not cmd:
            continue
        script_id = f"ir_{brand}_{device_type}_{_sanitize_id(btn.name)}"
        cards.append({
            "name": btn.name,
            "icon": _icon_for_button(btn.name),
            "color": _color_for_button(btn.name),
            "entity": f"script.{script_id}",
        })

    if not cards:
        return ""

    lines: list[str] = []
    lines.append("type: custom:stack-in-card")
    lines.append("mode: vertical")
    lines.append("cards:")

    # Group into pairs for horizontal-stack rows
    for i in range(0, len(cards), 2):
        pair = cards[i:i + 2]
        if len(pair) == 2:
            lines.append("  - type: horizontal-stack")
            lines.append("    cards:")
            for card in pair:
                _append_mushroom_card(lines, card, marker_indent=6)
        else:
            _append_mushroom_card(lines, pair[0], marker_indent=2)

    return "\n".join(lines)


def _append_mushroom_card(
    lines: list[str], card: dict, marker_indent: int
) -> None:
    """Append a mushroom-template-card YAML block.

    marker_indent is the column where ``- `` starts.
    Content aligns at marker_indent + 2 (after the ``- ``).
    """
    m = " " * marker_indent + "- "
    p = " " * (marker_indent + 2)

    lines.append(f"{m}type: custom:mushroom-template-card")
    lines.append(f"{p}entity: {card['entity']}")
    lines.append(f"{p}icon: {card['icon']}")
    lines.append(f"{p}primary: \"{card['name']}\"")
    lines.append(f"{p}secondary: \"\"")
    lines.append(f"{p}layout: vertical")
    lines.append(f"{p}icon_color: {card['color']}")
    lines.append(f"{p}tap_action:")
    lines.append(f"{p}  action: call-service")
    lines.append(f"{p}  service: script.turn_on")
    lines.append(f"{p}  target:")
    lines.append(f"{p}    entity_id: {card['entity']}")


def save_ha_scripts(
    scripts_yaml: str,
    ha_config_dir: str,
) -> dict:
    """Append generated scripts to HA's scripts.yaml.

    Returns {"path": str, "merged": bool}.
    """
    scripts_path = os.path.join(ha_config_dir, "scripts.yaml")
    logger.info("save_ha_scripts: writing to %s", scripts_path)

    os.makedirs(os.path.dirname(scripts_path) or ".", exist_ok=True)

    if os.path.exists(scripts_path):
        with open(scripts_path, "r") as f:
            existing = f.read()

        # Check for duplicate script IDs already in the file
        new_ids = set(re.findall(r"^(ir_\w+):", scripts_yaml, re.MULTILINE))
        existing_ids = set(re.findall(r"^(ir_\w+):", existing, re.MULTILINE))
        dupes = new_ids & existing_ids

        if dupes:
            # Remove OLD entries from the existing file so the new ones replace them
            filtered_lines: list[str] = []
            skip = False
            for line in existing.splitlines():
                id_match = re.match(r"^(ir_\w+):", line)
                if id_match:
                    skip = id_match.group(1) in dupes
                if not skip:
                    filtered_lines.append(line)
                elif line == "":
                    skip = False  # reset on blank line boundary
            existing = "\n".join(filtered_lines)

        # Strip trailing blank lines from existing before appending
        base = existing.rstrip()
        if base:
            new_content = base + "\n\n" + scripts_yaml.strip() + "\n"
        else:
            new_content = scripts_yaml.strip() + "\n"

        with open(scripts_path, "w") as f:
            f.write(new_content)
        return {"path": scripts_path, "merged": True}
    else:
        with open(scripts_path, "w") as f:
            f.write(scripts_yaml.strip() + "\n")
        return {"path": scripts_path, "merged": False}
