"""Generate ESPHome YAML config from confirmed working IR codes."""

from __future__ import annotations

import logging
import os
import re

from .discovery import ConfirmedButton, WizardSession
from .protocol_map import HOLD_BUTTONS, convert_code

logger = logging.getLogger(__name__)


def generate_yaml(session: WizardSession) -> str:
    """Generate button YAML entries for confirmed buttons (preview only).

    Returns only the indented button list items, not a complete ESPHome config.
    These entries are designed to sit under an existing ``button:`` key.
    """
    if not session.confirmed_buttons:
        return "# No buttons were confirmed during discovery."

    brand = session.matched_brand or "Custom"
    device_type = session.device_type or "Device"

    lines = []
    if session.matched_brand:
        lines.append(f"  # {brand} {device_type} — discovered by IR Remote Wizard")
    else:
        lines.append(f"  # Learned {device_type} — IR Remote Wizard")

    for btn in session.confirmed_buttons:
        cmd = convert_code(btn.protocol, btn.address, btn.command, btn.raw_data)
        if not cmd:
            continue

        button_id = _sanitize_id(btn.name)
        lines.append(f"  - platform: template")
        lines.append(f"    name: \"{btn.name}\"")
        lines.append(f"    id: btn_{button_id}")
        lines.append(f"    on_press:")

        if cmd.service == "send_ir_nec":
            lines.append(f"      - remote_transmitter.transmit_nec:")
            lines.append(f"          address: 0x{cmd.data['address']:04X}")
            lines.append(f"          command: 0x{cmd.data['command']:04X}")
        elif cmd.service == "send_ir_samsung":
            lines.append(f"      - remote_transmitter.transmit_samsung:")
            lines.append(f"          data: 0x{cmd.data['data']:08X}")
        elif cmd.service == "send_ir_sony":
            lines.append(f"      - remote_transmitter.transmit_sony:")
            lines.append(f"          data: 0x{cmd.data['data']:04X}")
            lines.append(f"          nbits: {cmd.data['nbits']}")
        elif cmd.service == "send_ir_rc5":
            lines.append(f"      - remote_transmitter.transmit_rc5:")
            lines.append(f"          address: 0x{cmd.data['address']:02X}")
            lines.append(f"          command: 0x{cmd.data['command']:02X}")
        elif cmd.service == "send_ir_rc6":
            lines.append(f"      - remote_transmitter.transmit_rc6:")
            lines.append(f"          address: 0x{cmd.data['address']:02X}")
            lines.append(f"          command: 0x{cmd.data['command']:02X}")
        elif cmd.service == "send_ir_pronto":
            lines.append(f"      - remote_transmitter.transmit_pronto:")
            lines.append(f"          data: \"{cmd.data['data']}\"")
        elif cmd.service == "send_ir_raw":
            code_str = str(cmd.data["code"])
            lines.append(f"      - remote_transmitter.transmit_raw:")
            lines.append(f"          carrier_frequency: 38000")
            lines.append(f"          code: {code_str}")

        lines.append("")

    return "\n".join(lines)


# Complete ESPHome config template for when no existing file is found.
# Uses !secret references (standard ESPHome pattern) and includes all
# API services needed for the wizard's IR transmission.
_FULL_CONFIG_TEMPLATE = """\
# IR Blaster — Generated by IR Remote Wizard

esphome:
  name: ir-blaster
  friendly_name: IR Blaster

esp32:
  board: esp32dev
  framework:
    type: arduino

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "IR-Blaster Fallback"
    password: "ir-blaster-fallback"

captive_portal:

logger:

api:
  encryption:
    key: !secret api_key
  services:
    - service: send_ir_nec
      variables:
        address: int
        command: int
      then:
        - remote_transmitter.transmit_nec:
            address: !lambda 'return address;'
            command: !lambda 'return command;'

    - service: send_ir_samsung
      variables:
        data: int
      then:
        - remote_transmitter.transmit_samsung:
            data: !lambda 'return data;'

    - service: send_ir_sony
      variables:
        data: int
        nbits: int
      then:
        - remote_transmitter.transmit_sony:
            data: !lambda 'return data;'
            nbits: !lambda 'return nbits;'

    - service: send_ir_rc5
      variables:
        address: int
        command: int
      then:
        - remote_transmitter.transmit_rc5:
            address: !lambda 'return address;'
            command: !lambda 'return command;'

    - service: send_ir_rc6
      variables:
        address: int
        command: int
      then:
        - remote_transmitter.transmit_rc6:
            address: !lambda 'return address;'
            command: !lambda 'return command;'

    - service: send_ir_raw
      variables:
        code: int[]
      then:
        - remote_transmitter.transmit_raw:
            carrier_frequency: 38000
            code: !lambda 'return code;'

    - service: send_ir_pronto
      variables:
        data: string
      then:
        - remote_transmitter.transmit_pronto:
            data: !lambda 'return data;'

ota:
  - platform: esphome
    password: !secret ota_password

remote_transmitter:
  pin: GPIO4
  carrier_duty_percent: 33%
  non_blocking: false

remote_receiver:
  pin:
    number: GPIO14
    inverted: true
    mode:
      input: true
      pullup: true
  dump: all
  tolerance: 25%
  idle: 25ms

status_led:
  pin: GPIO2

button:
"""


def _extract_existing_ids(content: str) -> set[str]:
    """Extract all button IDs already present in a YAML config."""
    return set(re.findall(r"^\s+id:\s+(btn_\w+)", content, re.MULTILINE))


def _filter_duplicate_buttons(buttons_yaml: str, existing_ids: set[str]) -> str:
    """Remove button entries whose IDs already exist in the config."""
    # Split on button boundaries (lines starting with "  - platform:")
    blocks: list[str] = []
    current: list[str] = []

    for line in buttons_yaml.splitlines():
        if line.strip().startswith("- platform:") and current:
            blocks.append("\n".join(current))
            current = []
        current.append(line)
    if current:
        blocks.append("\n".join(current))

    kept: list[str] = []
    for block in blocks:
        m = re.search(r"^\s+id:\s+(btn_\w+)", block, re.MULTILINE)
        if m and m.group(1) in existing_ids:
            continue  # skip duplicate
        kept.append(block)

    return "\n".join(kept)


def save_yaml(buttons_yaml: str, output_path: str) -> dict:
    """Save button definitions to the ESPHome config file.

    If the file already exists, appends the new buttons to it (preserving
    all existing configuration and buttons, skipping duplicates).
    If no file exists, generates a complete ESPHome config using
    ``!secret`` references.

    Returns ``{"merged": bool, "path": str}``.
    """
    logger.info("save_yaml called: output_path=%s, buttons_yaml length=%d",
                output_path, len(buttons_yaml))
    logger.info("save_yaml buttons_yaml preview: %s", buttons_yaml[:200])

    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    file_exists = os.path.exists(output_path)
    logger.info("save_yaml: file exists=%s", file_exists)

    if file_exists:
        with open(output_path, "r") as f:
            existing = f.read()
        logger.info("save_yaml: existing file size=%d", len(existing))

        # Treat empty files as new — write the full config template
        if not existing.strip():
            logger.info("save_yaml: file is empty, treating as new")
            full_content = _FULL_CONFIG_TEMPLATE + buttons_yaml + "\n"
            with open(output_path, "w") as f:
                f.write(full_content)
            logger.info("save_yaml: new file, wrote %d bytes", len(full_content))
            return {"merged": False, "path": output_path}

        # Skip buttons that already exist in the file
        existing_ids = _extract_existing_ids(existing)
        filtered = _filter_duplicate_buttons(buttons_yaml, existing_ids)
        logger.info("save_yaml: existing_ids=%s, filtered length=%d",
                    existing_ids, len(filtered))

        # Check if any actual button entries remain after dedup
        if "- platform:" not in filtered:
            logger.info("save_yaml: no new buttons to add, skipping write")
            return {"merged": True, "path": output_path, "skipped_all": True}

        has_button_section = bool(
            re.search(r"^button:\s*$", existing, re.MULTILINE)
        )
        logger.info("save_yaml: has_button_section=%s", has_button_section)

        if has_button_section:
            new_content = existing.rstrip() + "\n\n" + filtered + "\n"
        else:
            new_content = existing.rstrip() + "\n\nbutton:\n" + filtered + "\n"

        with open(output_path, "w") as f:
            f.write(new_content)
        logger.info("save_yaml: merged, wrote %d bytes", len(new_content))
        return {"merged": True, "path": output_path}
    else:
        full_content = _FULL_CONFIG_TEMPLATE + buttons_yaml + "\n"
        with open(output_path, "w") as f:
            f.write(full_content)
        logger.info("save_yaml: new file, wrote %d bytes", len(full_content))
        return {"merged": False, "path": output_path}


def _sanitize_id(name: str) -> str:
    """Convert a button name to a valid ESPHome ID."""
    return name.lower().replace(" ", "_").replace("-", "_")
